/*
          # [Operation Name]
          Correção e Recriação do Schema Completo da Aplicação

          ## Query Description: [Este script corrige um erro de tipo de dado na tabela 'notifications' e recria de forma segura o schema necessário para as funcionalidades de seguir, mensagens, notificações e assinaturas. Ele primeiro remove as tabelas e tipos criados incorretamente para garantir uma instalação limpa e depois os recria com a estrutura correta.
          
          Atenção: Se você já inseriu dados de teste nessas tabelas, eles serão perdidos. Como a migração anterior falhou, é provável que não haja dados a serem perdidos.]
          
          ## Metadata:
          - Schema-Category: ["Structural"]
          - Impact-Level: ["Medium"]
          - Requires-Backup: false
          - Reversible: false
          
          ## Structure Details:
          - Tabelas Afetadas: followers, subscriptions, messages, notifications
          - Tipos Afetados: notification_type
          - Funções Afetadas: handle_new_like, handle_new_comment, handle_new_follower
          
          ## Security Implications:
          - RLS Status: Habilitado para todas as novas tabelas.
          - Policy Changes: Sim, políticas de acesso são criadas para todas as novas tabelas.
          - Auth Requirements: As políticas dependem do ID do usuário autenticado (auth.uid()).
          
          ## Performance Impact:
          - Indexes: Índices são criados nas chaves estrangeiras para otimizar as consultas.
          - Triggers: Três gatilhos são criados para automatizar a criação de notificações.
          - Estimated Impact: Baixo impacto em um banco de dados novo. A criação de gatilhos pode adicionar uma pequena sobrecarga nas operações de INSERT.
          */

-- Passo 0: Limpeza (Remove estruturas da migração anterior que falhou)
DROP TABLE IF EXISTS public.notifications;
DROP TABLE IF EXISTS public.messages;
DROP TABLE IF EXISTS public.followers;
DROP TABLE IF EXISTS public.subscriptions;
DROP TYPE IF EXISTS public.notification_type;

-- Passo 1: Criar a tabela de seguidores (followers)
CREATE TABLE IF NOT EXISTS public.followers (
    follower_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    following_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamptz DEFAULT now(),
    PRIMARY KEY (follower_id, following_id)
);
COMMENT ON TABLE public.followers IS 'Armazena as relações de seguidores entre usuários.';
ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Usuários podem ver relações de seguir" ON public.followers FOR SELECT USING (true);
CREATE POLICY "Usuários podem seguir outros" ON public.followers FOR INSERT WITH CHECK (auth.uid() = follower_id);
CREATE POLICY "Usuários podem deixar de seguir" ON public.followers FOR DELETE USING (auth.uid() = follower_id);

-- Passo 2: Criar a tabela de assinaturas (subscriptions)
CREATE TABLE IF NOT EXISTS public.subscriptions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
    plan text NOT NULL,
    status text NOT NULL,
    start_date timestamptz DEFAULT now(),
    end_date timestamptz,
    created_at timestamptz DEFAULT now()
);
COMMENT ON TABLE public.subscriptions IS 'Armazena o status da assinatura de cada usuário.';
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Usuários podem ver sua própria assinatura" ON public.subscriptions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Usuários podem criar ou atualizar sua assinatura" ON public.subscriptions FOR ALL USING (auth.uid() = user_id);

-- Passo 3: Criar a tabela de mensagens (messages)
CREATE TABLE IF NOT EXISTS public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamptz DEFAULT now()
);
COMMENT ON TABLE public.messages IS 'Armazena as mensagens trocadas entre usuários.';
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Usuários podem ver as mensagens que enviaram ou receberam" ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Usuários podem enviar mensagens" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);

-- Passo 4: Criar a tabela de notificações (notifications) - COM A CORREÇÃO
CREATE TYPE public.notification_type AS ENUM ('like', 'comment', 'follow');
CREATE TABLE IF NOT EXISTS public.notifications (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    recipient_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    post_id uuid REFERENCES public.posts(id) ON DELETE CASCADE, -- CORRIGIDO PARA UUID
    type notification_type NOT NULL,
    is_read boolean DEFAULT false,
    created_at timestamptz DEFAULT now()
);
COMMENT ON TABLE public.notifications IS 'Armazena notificações para os usuários.';
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Usuários podem ver suas próprias notificações" ON public.notifications FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Usuários podem atualizar suas notificações (marcar como lida)" ON public.notifications FOR UPDATE USING (auth.uid() = recipient_id);


-- Passo 5: Criar funções e gatilhos para notificações automáticas

-- Gatilho para notificação de novo 'like'
CREATE OR REPLACE FUNCTION public.handle_new_like()
RETURNS TRIGGER AS $$
DECLARE
  recipient_user_id uuid;
BEGIN
  -- Descobre o dono do post
  SELECT user_id INTO recipient_user_id FROM public.posts WHERE id = NEW.post_id;
  
  -- Insere a notificação, mas não se o usuário curtiu o próprio post
  IF recipient_user_id <> NEW.user_id THEN
    INSERT INTO public.notifications (recipient_id, sender_id, post_id, type)
    VALUES (recipient_user_id, NEW.user_id, NEW.post_id, 'like');
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_new_like ON public.likes;
CREATE TRIGGER on_new_like
  AFTER INSERT ON public.likes
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_like();

-- Gatilho para notificação de novo 'comment'
CREATE OR REPLACE FUNCTION public.handle_new_comment()
RETURNS TRIGGER AS $$
DECLARE
  recipient_user_id uuid;
BEGIN
  SELECT user_id INTO recipient_user_id FROM public.posts WHERE id = NEW.post_id;
  
  IF recipient_user_id <> NEW.user_id THEN
    INSERT INTO public.notifications (recipient_id, sender_id, post_id, type)
    VALUES (recipient_user_id, NEW.user_id, NEW.post_id, 'comment');
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_new_comment ON public.comments;
CREATE TRIGGER on_new_comment
  AFTER INSERT ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_comment();
  
-- Gatilho para notificação de novo 'follower'
CREATE OR REPLACE FUNCTION public.handle_new_follower()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.notifications (recipient_id, sender_id, type)
  VALUES (NEW.following_id, NEW.follower_id, 'follow');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_new_follower ON public.followers;
CREATE TRIGGER on_new_follower
  AFTER INSERT ON public.followers
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_follower();
