/*
          # [Operação de Correção e Reconstrução]
          Este script remove e recria de forma segura todas as tabelas, funções e gatilhos para as funcionalidades de Seguir, Assinaturas, Mensagens e Notificações. Ele foi projetado para ser executado mesmo que migrações anteriores tenham falhado, garantindo um estado de banco de dados limpo e correto.

          ## Query Description: ["Esta operação irá apagar e recriar as tabelas `followers`, `subscriptions`, `messages` e `notifications`. Se houver algum dado de teste nessas tabelas, ele será perdido. As tabelas de `posts`, `likes` e `comments` não serão afetadas."]
          
          ## Metadata:
          - Schema-Category: ["Structural"]
          - Impact-Level: ["Medium"]
          - Requires-Backup: false
          - Reversible: false
          
          ## Structure Details:
          - Tabelas Afetadas: followers, subscriptions, messages, notifications
          - Funções Afetadas: Todas as funções de `create_notification_*`, `handle_new_user`, `get_conversations`, `get_*_count`
          - Triggers Afetados: Todos os gatilhos associados às tabelas acima.
          
          ## Security Implications:
          - RLS Status: [Enabled]
          - Policy Changes: [Yes]
          - Auth Requirements: [service_role]
          
          ## Performance Impact:
          - Indexes: [Re-created]
          - Triggers: [Re-created]
          - Estimated Impact: [Baixo, a operação é rápida em esquemas vazios ou pequenos.]
          */

-- 1. LIMPEZA SEGURA DE OBJETOS EXISTENTES

-- Drop triggers primeiro, pois dependem de funções e tabelas.
DROP TRIGGER IF EXISTS on_like_created ON public.likes;
DROP TRIGGER IF EXISTS on_comment_created ON public.comments;
DROP TRIGGER IF EXISTS on_follow_created ON public.followers;
-- O trigger on_auth_user_created é mantido e atualizado com CREATE OR REPLACE

-- Drop funções.
DROP FUNCTION IF EXISTS public.create_notification_on_like();
DROP FUNCTION IF EXISTS public.create_notification_on_comment();
DROP FUNCTION IF EXISTS public.create_notification_on_follow();
DROP FUNCTION IF EXISTS public.get_conversations(uuid);
DROP FUNCTION IF EXISTS public.get_followers_count(uuid);
DROP FUNCTION IF EXISTS public.get_following_count(uuid);

-- Drop tabelas.
DROP TABLE IF EXISTS public.notifications;
DROP TABLE IF EXISTS public.messages;
DROP TABLE IF EXISTS public.subscriptions;
DROP TABLE IF EXISTS public.followers;


-- 2. RECONSTRUÇÃO DO ESQUEMA

-- Tabela de Seguidores
CREATE TABLE public.followers (
    follower_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    following_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (follower_id, following_id)
);
COMMENT ON TABLE public.followers IS 'Armazena as relações de seguir entre usuários.';

-- Tabela de Assinaturas
CREATE TABLE public.subscriptions (
    user_id uuid PRIMARY KEY NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    plan text NOT NULL,
    status text NOT NULL,
    start_date timestamp with time zone NOT NULL,
    end_date timestamp with time zone
);
COMMENT ON TABLE public.subscriptions IS 'Armazena os planos de assinatura dos usuários.';

-- Tabela de Mensagens
CREATE TABLE public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.messages IS 'Armazena as mensagens diretas entre usuários.';

-- Tabela de Notificações (com a correção do tipo de dado)
CREATE TABLE public.notifications (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    recipient_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type text NOT NULL,
    post_id uuid REFERENCES public.posts(id) ON DELETE CASCADE,
    comment_id bigint REFERENCES public.comments(id) ON DELETE CASCADE,
    is_read boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.notifications IS 'Armazena notificações de usuários para curtidas, comentários e seguidores.';

-- 3. FUNÇÕES (com segurança aprimorada)

-- Função para criar perfil de usuário
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'user_name',
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$;

-- Função para notificação de curtida
CREATE OR REPLACE FUNCTION public.create_notification_on_like()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  post_author_id uuid;
BEGIN
  SELECT user_id INTO post_author_id FROM posts WHERE id = NEW.post_id;
  IF post_author_id != NEW.user_id THEN
    INSERT INTO public.notifications (recipient_id, sender_id, type, post_id)
    VALUES (post_author_id, NEW.user_id, 'like', NEW.post_id);
  END IF;
  RETURN NEW;
END;
$$;

-- Função para notificação de comentário
CREATE OR REPLACE FUNCTION public.create_notification_on_comment()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  post_author_id uuid;
BEGIN
  SELECT user_id INTO post_author_id FROM posts WHERE id = NEW.post_id;
  IF post_author_id != NEW.user_id THEN
    INSERT INTO public.notifications (recipient_id, sender_id, type, post_id, comment_id)
    VALUES (post_author_id, NEW.user_id, 'comment', NEW.post_id, NEW.id);
  END IF;
  RETURN NEW;
END;
$$;

-- Função para notificação de seguir
CREATE OR REPLACE FUNCTION public.create_notification_on_follow()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
BEGIN
  INSERT INTO public.notifications (recipient_id, sender_id, type)
  VALUES (NEW.following_id, NEW.follower_id, 'follow');
  RETURN NEW;
END;
$$;

-- Função para buscar conversas (otimizada)
CREATE OR REPLACE FUNCTION public.get_conversations(p_user_id uuid)
RETURNS TABLE(user_id uuid, username text, avatar_url text, last_message_at timestamptz)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  WITH last_messages AS (
    SELECT
      CASE WHEN sender_id = p_user_id THEN receiver_id ELSE sender_id END as other_user_id,
      MAX(created_at) as max_created_at
    FROM messages
    WHERE sender_id = p_user_id OR receiver_id = p_user_id
    GROUP BY other_user_id
  )
  SELECT
    p.id as user_id,
    p.username,
    p.avatar_url,
    lm.max_created_at as last_message_at
  FROM last_messages lm
  JOIN profiles p ON p.id = lm.other_user_id
  ORDER BY lm.max_created_at DESC;
END;
$$;

-- Funções de contagem
CREATE OR REPLACE FUNCTION public.get_followers_count(p_user_id uuid) RETURNS integer LANGUAGE plpgsql AS $$
DECLARE followers_count integer;
BEGIN SELECT count(*) INTO followers_count FROM public.followers WHERE following_id = p_user_id; RETURN followers_count; END; $$;

CREATE OR REPLACE FUNCTION public.get_following_count(p_user_id uuid) RETURNS integer LANGUAGE plpgsql AS $$
DECLARE following_count integer;
BEGIN SELECT count(*) INTO following_count FROM public.followers WHERE follower_id = p_user_id; RETURN following_count; END; $$;


-- 4. GATILHOS (TRIGGERS)

-- O gatilho para handle_new_user já deve existir, mas recriá-lo garante o estado correto.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

CREATE TRIGGER on_like_created
  AFTER INSERT ON public.likes
  FOR EACH ROW EXECUTE FUNCTION public.create_notification_on_like();

CREATE TRIGGER on_comment_created
  AFTER INSERT ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.create_notification_on_comment();

CREATE TRIGGER on_follow_created
  AFTER INSERT ON public.followers
  FOR EACH ROW EXECUTE FUNCTION public.create_notification_on_follow();


-- 5. POLÍTICAS DE SEGURANÇA (RLS)

-- Habilitar RLS
ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- Limpar políticas antigas para evitar conflitos
DROP POLICY IF EXISTS "all_users_rls" ON public.followers;
DROP POLICY IF EXISTS "all_users_rls" ON public.subscriptions;
DROP POLICY IF EXISTS "all_users_rls" ON public.messages;
DROP POLICY IF EXISTS "all_users_rls" ON public.notifications;

-- Criar políticas
CREATE POLICY "all_users_rls" ON public.followers FOR ALL
  USING (auth.role() = 'authenticated');

CREATE POLICY "all_users_rls" ON public.subscriptions FOR ALL
  USING (auth.uid() = user_id);

CREATE POLICY "all_users_rls" ON public.messages FOR ALL
  USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

CREATE POLICY "all_users_rls" ON public.notifications FOR ALL
  USING (auth.uid() = recipient_id);
